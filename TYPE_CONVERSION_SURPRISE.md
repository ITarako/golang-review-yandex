Результат выполнения вызывает реализацию метода MethodA() из type A, но при этом содержимое поля N сохраняется из экземпляра типа B, который был приведен к типу A.

При приведении типа в Go, если структуры имеют одинаковую структуру полей (в вашем случае обе структуры A и B имеют поле N int), то приведение типа сохраняет значения полей.

Это объясняет, почему при вызове метода MethodA() через переменную a выводится "MethodA from A", так как переменная a была создана как экземпляр типа A. Однако, при обращении к полю N через переменную a, значение 123 сохраняется, так как при приведении типа N было скопировано из экземпляра типа B.

При приведении типа в Go, если структуры имеют одинаковую структуру полей (в вашем случае обе структуры A и B имеют поле N int), то приведение типа сохраняет значения полей.

Если вы хотите, чтобы результат вызова метода MethodA() использовал реализацию из типа B, вам нужно использовать интерфейс и приведение типа в соответствии с интерфейсом (`var a A; a = b`).

```go
package main

import "fmt"

type A struct {
	N int
}

func (A) MethodA() {
	fmt.Println("MethodA from A")
}

type B struct {
	N int
}

func (b B) MethodA() {
	fmt.Println("MethodA from B")
}

func main() {
	b := B{123}
	a := A(b)    // Приведение типа B к типу A
	a.MethodA()  // MethodA from A
	println(a.N) // 123 !!!
}
```